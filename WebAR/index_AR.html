<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport"
        content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">

        <title>WebXR Demo</title>

        <!-- include three.js -->
        <script src="https://unpkg.com/three@0.126.0/build/three.js"></script>
        <script src="https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js"></script>
        <script src="./game.js"></script>
    </head>

    <body>
        <button onclick="activateXR()">Start WebXR</button>

        <script>

            //Constants
            const ENEMY_GEOMETRY = new THREE.BoxGeometry(0.1, 0.1, 0.1);
            const ENEMY_MATERIAL = new THREE.MeshBasicMaterial( {color: 0xffffff} );

            //List of Objects which get destroyed after every frame
            let arrObjectsToDestroy = [];

            async function activateXR() {

                // add a canvas
                const canvas = document.createElement("canvas");
                document.body.appendChild(canvas);
                const gl = canvas.getContext("webgl", {xrCompatible: true});

                // three.js initialization
                const scene = new THREE.Scene();

                const axesHelper = new THREE.AxesHelper(20);
                scene.add(axesHelper);

                // test cube materials
                const materials = [
                    new THREE.MeshBasicMaterial({color: 0xff0000}),
                    new THREE.MeshBasicMaterial({color: 0x0000ff}),
                    new THREE.MeshBasicMaterial({color: 0x00ff00}),
                    new THREE.MeshBasicMaterial({color: 0xff00ff}),
                    new THREE.MeshBasicMaterial({color: 0x00ffff}),
                    new THREE.MeshBasicMaterial({color: 0xffff00})
                ];

                const ambientLight = new THREE.AmbientLight();
                scene.add(ambientLight);

                // WebGLRenderer
                const renderer = new THREE.WebGLRenderer({
                    alpha: true,
                    preserveDrawingBuffer: true,
                    canvas: canvas,
                    context: gl
                });
                renderer.autoClear = false;

                // disable matrix auto updates from three.js
                const camera = new THREE.PerspectiveCamera();
                camera.matrixAutoUpdate = false;

                // Initialize WebXR session using "immersive-ar"
                const session = await navigator.xr.requestSession("immersive-ar", {requiredFeatures: ['hit-test']});
                session.updateRenderState({
                    baseLayer: new XRWebGLLayer(session, gl)    
                });
                
                // create a position reference near the user
                const referenceSpace = await session.requestReferenceSpace('local');

                const viewerSpace = await session.requestReferenceSpace('viewer');

                // hit testing with user as the origin
                const hitTestSource = await session.requestHitTestSource({space: viewerSpace});

                // for loading 3D objects
                const gltfLoader = new THREE.GLTFLoader();
                const objectLoader = new THREE.ObjectLoader();
                let arrow;
                gltfLoader.load("https://immersive-web.github.io/webxr-samples/media/gltf/reticle/reticle.gltf", function(gltf) {
                    arrow = gltf.scene;
                    arrow.visible = false;
                    scene.add(arrow);
                })

                let dino_idle;
                //objectLoader.load("./src/models/Dino_Walk01.obj", function(object) {
                gltfLoader.load("./src/models/Dino_Idle.gltf", function(gltf) {
                    dino_idle = gltf.scene;
                    dino_idle.position.z = -1;
                    dino_idle.scale.x = 0.1;
                    dino_idle.scale.y = 0.1;
                    dino_idle.scale.z = 0.1;
                    scene.add(dino_idle);
                })


                //Game Instance/Mechanics
                let instanceHandler = new InstanceHandler(1, gameLoop);
                instanceHandler.Init();

                //get an instance and start the game
                let game = instanceHandler.GetInstance();

                instanceHandler.Start();
                
                function gameLoop() {
                    //if there are obstacles in the game
                    if(game.gameHandler.arrObstacles.length > 0) {

                        let id = 1;

                        //Remove all objects
                        arrObjectsToDestroy.forEach(object => {
                            removeEntity(object);
                        });

                        //Add each enemy to array
                        game.gameHandler.arrObstacles.forEach(function(obstacle) {

                            //draw obstacle if it is inside the canvas
                            if(obstacle.v2Pos.dX >- 100) {
                                let enemy = new THREE.Mesh(ENEMY_GEOMETRY, ENEMY_MATERIAL);

                                enemy.name = id.toString();
                                id++;

                                enemy.position.y = obstacle.v2Pos.dY / 100;
                                enemy.position.x = obstacle.v2Pos.dX / 500;
                                arrObjectsToDestroy.push(enemy);
                            }
                        });
                        
                        //Draw all new Objects
                        arrObjectsToDestroy.forEach(object => {
                            scene.add(object);
                        });
                    }
                }

                function removeEntity(object) {
                    var selectedObject = scene.getObjectByName(object.name);
                    scene.remove(selectedObject);
                }

                // render loop for drawing in AR
                const onXRFrame = (time, frame) => {
                    // next draw request
                    session.requestAnimationFrame(onXRFrame);

                    // bind graphics framebuffer to baseLayer framebuffer
                    gl.bindFramebuffer(gl.FRAMEBUFFER, session.renderState.baseLayer.framebuffer);

                    // retrieve position of the device WARNING: "XRFrame.getViewerPose" can return null when tracking is tried to be first established
                    const pose = frame.getViewerPose(referenceSpace);

                    if (pose != null) {
                        const view = pose.views[0];

                        const viewport = session.renderState.baseLayer.getViewport(view);
                        renderer.setSize(viewport.width, viewport.height)

                        // Use the view's transform matrix and projection matrix to configure the THREE.camera
                        camera.matrix.fromArray(view.transform.matrix);
                        camera.projectionMatrix.fromArray(view.projectionMatrix);
                        camera.updateMatrixWorld(true);

                        const hitTestResults = frame.getHitTestResults(hitTestSource);
                        if (hitTestResults.length > 0 && arrow) {
                            const hitPose = hitTestResults[0].getPose(referenceSpace);
                            arrow.visible = true;
                            arrow.position.set(hitPose.transform.position.x, hitPose.transform.position.y, hitPose.transform.position.z);
                            arrow.updateMatrixWorld(true);
                        }
                        // render the scene
                        renderer.render(scene, camera);
                    }

                    
                }
                session.requestAnimationFrame(onXRFrame);
            }
        </script>
    </body>
</html>