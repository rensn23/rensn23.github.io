<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">

    <title>WebXR Demo</title>

    <!-- include three.js -->
    <script src="https://unpkg.com/three@0.126.0/build/three.js"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="./game.js"></script>
</head>

<body>
    <button onclick="activateXR()">Start WebXR</button>

    <script>

        //Constants
        const SCALE = 250;
        const PLAYER_MATERIAL = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const ENEMY_MATERIAL = new THREE.MeshBasicMaterial({ color: 0xffffff });

        //List of Objects which get destroyed after frame
        let arrObjectsToRemove = [];
        //List of Enemies which currently exist in the scene
        let arrCurrentSceneEnemieIDs = [];
        let arrCurrentGameEnemieIDs = [];

        let instanceHandler;
        let game;

        let player = null;

        //Reticles/Cursors
        let reticle1;
        let reticle2;
        let direction; //reticle2.pos - reticle1.pos
        let bReticle1Placed = false;
        let bReticle2Placed = false;

        async function activateXR() {

            // add a canvas
            const canvas = document.createElement("canvas");
            document.body.appendChild(canvas);
            const gl = canvas.getContext("webgl", { xrCompatible: true });

            // three.js initialization
            const scene = new THREE.Scene();

            const axesHelper = new THREE.AxesHelper(20);
            scene.add(axesHelper);

            const ambientLight = new THREE.AmbientLight();
            scene.add(ambientLight);

            // WebGLRenderer
            const renderer = new THREE.WebGLRenderer({
                alpha: true,
                preserveDrawingBuffer: true,
                canvas: canvas,
                context: gl
            });
            renderer.autoClear = false;

            // disable matrix auto updates from three.js
            const camera = new THREE.PerspectiveCamera();
            camera.matrixAutoUpdate = false;

            // Initialize WebXR session using "immersive-ar"
            const session = await navigator.xr.requestSession("immersive-ar", { requiredFeatures: ['hit-test'] });
            session.updateRenderState({
                baseLayer: new XRWebGLLayer(session, gl)
            });

            // create a position reference near the user
            const referenceSpace = await session.requestReferenceSpace('local');

            const viewerSpace = await session.requestReferenceSpace('viewer');

            // hit testing with user as the origin
            const hitTestSource = await session.requestHitTestSource({ space: viewerSpace });

            // for loading 3D objects
            const gltfLoader = new THREE.GLTFLoader();
            const objectLoader = new THREE.ObjectLoader();
            let arrow;
            gltfLoader.load("https://immersive-web.github.io/webxr-samples/media/gltf/reticle/reticle.gltf", function (gltf) {
                arrow = gltf.scene;
                arrow.visible = false;
                scene.add(arrow);
            })

            // let dino_idle;
            // gltfLoader.load("./src/models/Dino_Idle.gltf", function(gltf) {
            //     dino_idle = gltf.scene;
            //     dino_idle.position.z = -1;
            //     dino_idle.scale.x = 0.1;
            //     dino_idle.scale.y = 0.1;
            //     dino_idle.scale.z = 0.1;
            //     scene.add(dino_idle);
            // })

            session.addEventListener("select", (event) => {
                if (!bReticle1Placed) {
                    gltfLoader.load("https://immersive-web.github.io/webxr-samples/media/gltf/reticle/reticle.gltf", function (gltf) {
                        reticle1 = gltf.scene;
                        reticle1.position.set(arrow.position.x, arrow.position.y, arrow.position.z)
                        scene.add(reticle1);
                    })
                    bReticle1Placed = true;
                }
                else {
                    gltfLoader.load("https://immersive-web.github.io/webxr-samples/media/gltf/reticle/reticle.gltf", function (gltf) {
                        reticle2 = gltf.scene;
                        reticle2.position.set(arrow.position.x, arrow.position.y, arrow.position.z)
                        direction = new THREE.Vector3(reticle2.position.x - reticle1.position.x, reticle2.position.y - reticle1.position.y, reticle2.position.z - reticle1.position.z);
                        console.log(direction);
                        direction.normalize();
                        console.log(direction);
                        arrow.visible = false;
                        scene.add(reticle2);
                    })
                    bReticle2Placed = true;
                    startGame();
                }
            });

            function startGame() {

                //Game Instance/Mechanics
                instanceHandler = new InstanceHandler(1, gameLoop);
                instanceHandler.Init();

                //get an instance and start the game
                game = instanceHandler.GetInstance();

                instanceHandler.Start();
            }

            function gameLoop() {

                arrCurrentGameEnemieIDs = [];
                arrObjectsToRemove = [];

                instanceHandler.Act(Predict(instanceHandler.GetState()));

                game.gameHandler.arrObstacles.forEach(enemieGame => {

                    arrCurrentGameEnemieIDs.push(enemieGame.nObstacleUID);

                    if (!arrCurrentSceneEnemieIDs.includes(enemieGame.nObstacleUID)) {

                        let newEnemieGeometry = new THREE.BoxGeometry(enemieGame.dWidth / SCALE, enemieGame.dHeight / SCALE, 25 / SCALE);
                        let newEnemie = new THREE.Mesh(newEnemieGeometry, ENEMY_MATERIAL);

                        newEnemie.position.x = (enemieGame.v2Pos.dX / SCALE + (enemieGame.dWidth / 2 / SCALE)) * direction.x + reticle1.position.x;
                        newEnemie.position.y = (enemieGame.v2Pos.dY / SCALE + (enemieGame.dHeight / 2 / SCALE)) * direction.y + reticle1.position.y;
                        newEnemie.position.z = reticle1.position.z;

                        newEnemie.name = enemieGame.nObstacleUID.toString();

                        arrCurrentSceneEnemieIDs.push(enemieGame.nObstacleUID);
                        scene.add(newEnemie);
                    }
                });

                //Update current enemie's positions
                arrCurrentSceneEnemieIDs.forEach(curSceneEnemieID => {
                    let curEnemieObject = scene.getObjectByName(curSceneEnemieID.toString());
                    if (curEnemieObject === null) return;

                    if (!arrCurrentGameEnemieIDs.includes(curSceneEnemieID)) {
                        arrObjectsToRemove.push(curSceneEnemieID);
                        arrCurrentSceneEnemieIDs.shift();
                    } else {
                        game.gameHandler.arrObstacles.forEach(enemieGame => {
                            if (curSceneEnemieID == enemieGame.nObstacleUID) {
                                curEnemieObject.position.x = (enemieGame.v2Pos.dX / SCALE + (enemieGame.dWidth / 2 / SCALE)) * direction.x + reticle1.position.x;
                            }
                        });
                    }
                });

                //Update Player
                if (player !== null) {
                    let playerGame = game.gameHandler.player;
                    player.scale.y = playerGame.dHeight / 50;
                    player.position.x = (playerGame.v2Pos.dX / SCALE + (playerGame.dWidth / 2 / SCALE)) * direction.x + reticle1.position.x;
                    player.position.y = (playerGame.v2Pos.dY / SCALE + (playerGame.dHeight / 2 / SCALE)) * direction.y + reticle1.position.y;
                }
                else {
                    let playerGame = game.gameHandler.player;
                    let playerGeometry = new THREE.BoxGeometry(25 / SCALE, 50 / SCALE, 25 / SCALE);
                    player = new THREE.Mesh(playerGeometry, PLAYER_MATERIAL);
                    player.position.x = (playerGame.v2Pos.dX / SCALE + (playerGame.dWidth / 2 / SCALE)) * direction.x + reticle1.position.x;
                    player.position.y = (playerGame.v2Pos.dY / SCALE + (playerGame.dHeight / 2 / SCALE)) * direction.y + reticle1.position.y;
                    player.position.z = reticle1.position.z;
                    scene.add(player);
                }

                //Remove all objects
                arrObjectsToRemove.forEach(objectID => {
                    let selectedObject = scene.getObjectByName(objectID.toString());
                    scene.remove(selectedObject);
                });
            }

            // render loop for drawing in AR
            const onXRFrame = (time, frame) => {
                // next draw request
                session.requestAnimationFrame(onXRFrame);

                // bind graphics framebuffer to baseLayer framebuffer
                gl.bindFramebuffer(gl.FRAMEBUFFER, session.renderState.baseLayer.framebuffer);

                // retrieve position of the device WARNING: "XRFrame.getViewerPose" can return null when tracking is tried to be first established
                const pose = frame.getViewerPose(referenceSpace);

                if (pose != null) {
                    const view = pose.views[0];

                    const viewport = session.renderState.baseLayer.getViewport(view);
                    renderer.setSize(viewport.width, viewport.height)

                    // Use the view's transform matrix and projection matrix to configure the THREE.camera
                    camera.matrix.fromArray(view.transform.matrix);
                    camera.projectionMatrix.fromArray(view.projectionMatrix);
                    camera.updateMatrixWorld(true);

                    if (!bReticle2Placed) {
                        const hitTestResults = frame.getHitTestResults(hitTestSource);
                        if (hitTestResults.length > 0 && arrow) {
                            const hitPose = hitTestResults[0].getPose(referenceSpace);
                            arrow.visible = true;
                            arrow.position.set(hitPose.transform.position.x, hitPose.transform.position.y, hitPose.transform.position.z);
                            arrow.updateMatrixWorld(true);
                        }
                    }

                    // render the scene
                    renderer.render(scene, camera);
                }
            }
            session.requestAnimationFrame(onXRFrame);
        }

        //function to Predict
        function Predict(state) {
            if (state.bGame == false || state.arrNObstaclesID[0] == 3) {
                return enumAction.none;
            }

            if (state.arrDDistance[1] + 0.12 * state.nScore - state.arrDDistance[0] + 0.12 * state.nScore < 250 && state.arrDDistance[0] < 120 + 0.12 * state.nScore && (state.arrNObstaclesID[0] == 0 || state.arrNObstaclesID[0] == 1 || state.arrNObstaclesID[0] == 4 || state.arrNObstaclesID[0] == 5)) {
                if (bDuck) {
                    bDuck = false;
                    return enumAction.unduck;
                }
                return enumAction.jump;
            } else if (state.arrDDistance[0] < 120 + 0.12 * state.nScore && state.arrDDistance[0] > 0 + 0.12 * state.nScore && (state.arrNObstaclesID[0] == 0)) {
                if (bDuck) {
                    bDuck = false;
                    return enumAction.unduck;
                }
                return enumAction.jump;
            } else if (state.arrDDistance[0] < 120 + 0.12 * state.nScore && state.arrDDistance[0] > 0 + 0.12 * state.nScore && (state.arrNObstaclesID[0] == 1)) {
                if (bDuck) {
                    bDuck = false;
                    return enumAction.unduck;
                }
                return enumAction.jump;
            } else if (state.arrDDistance[0] < 120 + 0.12 * state.nScore && state.arrDDistance[0] > -25 - 0.12 * state.nScore && (state.arrNObstaclesID[0] == 4)) {
                if (bDuck) {
                    bDuck = false;
                    return enumAction.unduck;
                }
                return enumAction.jump;
            } else if (state.arrDDistance[0] < 120 + 0.12 * state.nScore && state.arrDDistance[0] > -35 - 0.12 * state.nScore && (state.arrNObstaclesID[0] == 5)) {
                if (bDuck) {
                    bDuck = false;
                    return enumAction.unduck;
                }
                return enumAction.jump;
            } else if (state.arrDDistance[0] < 120 + 0.12 * state.nScore && state.arrDDistance[0] > -38 && !(state.arrNObstaclesID[0] == 0 || state.arrNObstaclesID[0] == 1 || state.arrNObstaclesID[0] == 4 || state.arrNObstaclesID[0] == 5)) {
                bDuck = true;
                return enumAction.duck;
            } else {
                if (!state.bGrounded) {
                    bDuck = true;
                    return enumAction.duck;
                }
                bDuck = false;
                return enumAction.unduck;
            }
        }

    </script>
</body>

</html>