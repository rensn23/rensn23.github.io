<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">

    <title>WebXR Demo</title>

    <!-- include three.js -->
    <script src="https://unpkg.com/three@0.126.0/build/three.js"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="./game.js"></script>
</head>

<body>
    <button onclick="activateXR()">Start WebXR</button>

    <script>

        //Constants
        const PLAYER_MATERIAL = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const ENEMY_MATERIAL = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const UNIT_VECTOR_X = new THREE.Vector3(1, 0, 0);
        const UNIT_VECTOR_Y = new THREE.Vector3(0, 1, 0);
        const gltfLoader = new THREE.GLTFLoader();  //For loading 3D objects

        let scale = 250;

        
        let arrObjectsToRemove = [];        //List of Objects which get destroyed after frame
        let arrCurrentSceneEnemieIDs = [];  //List of Enemies which currently exist in the scene
        let arrCurrentGameEnemieIDs = [];   //List of Enemies which currently exist in the game

        let instanceHandler;
        let game;

        let playerScene = null;     //Player in the 3D-Scene
        let playerGame;             //Player in the game

        //Reticles/Cursors
        let arrow;                  //The "preview" reticle that moves with the camera
        let reticle1;
        let reticle2;
        let direction;              //direction from reticle1 to reticle2
        let reticleAngle = 0;       //the angle between the direction and the x-axis
        let bReticle1Placed = false;
        let bReticle2Placed = false;

        async function activateXR() {

            //Add a canvas
            const canvas = document.createElement("canvas");
            document.body.appendChild(canvas);
            const gl = canvas.getContext("webgl", { xrCompatible: true });

            //Three.js initialization
            const scene = new THREE.Scene();

            //Axes Helper
            const axesHelper = new THREE.AxesHelper(20);
            scene.add(axesHelper);

            //Ambient Light
            const ambientLight = new THREE.AmbientLight();
            scene.add(ambientLight);

            // WebGLRenderer
            const renderer = new THREE.WebGLRenderer({
                alpha: true,
                preserveDrawingBuffer: true,
                canvas: canvas,
                context: gl
            });
            renderer.autoClear = false;

            //Disable matrix auto updates from three.js
            const camera = new THREE.PerspectiveCamera();
            camera.matrixAutoUpdate = false;

            //Initialize WebXR session using "immersive-ar"
            const session = await navigator.xr.requestSession("immersive-ar", { requiredFeatures: ['hit-test'] });
            session.updateRenderState({
                baseLayer: new XRWebGLLayer(session, gl)
            });

            //Create a position reference near the user
            const referenceSpace = await session.requestReferenceSpace('local');
            const viewerSpace = await session.requestReferenceSpace('viewer');

            //Hit testing with user as the origin
            const hitTestSource = await session.requestHitTestSource({ space: viewerSpace });

            //Load the reticle model
            gltfLoader.load("https://immersive-web.github.io/webxr-samples/media/gltf/reticle/reticle.gltf", function (gltf) {
                arrow = gltf.scene;
                arrow.visible = false;
                scene.add(arrow);
            })

            //Is called when user touches screen
            session.addEventListener("select", (event) => {
                if (!bReticle1Placed) {
                    gltfLoader.load("https://immersive-web.github.io/webxr-samples/media/gltf/reticle/reticle.gltf", function (gltf) {
                        reticle1 = gltf.scene;
                        reticle1.position.set(arrow.position.x, arrow.position.y, arrow.position.z)
                        reticle1.name = "reticle1";
                        scene.add(reticle1);
                    })
                    bReticle1Placed = true;
                }
                else {
                    gltfLoader.load("https://immersive-web.github.io/webxr-samples/media/gltf/reticle/reticle.gltf", function (gltf) {
                        reticle2 = gltf.scene;
                        reticle2.position.set(arrow.position.x, arrow.position.y, arrow.position.z)
                        reticle2.name = "reticle2";

                        direction = new THREE.Vector3(reticle2.position.x - reticle1.position.x, 0, reticle2.position.z - reticle1.position.z);
                        scale = min(scale, scale / direction.length());

                        if (reticle2.position.z < reticle1.position.z) {
                            reticleAngle = UNIT_VECTOR_X.angleTo(direction);
                        } else {
                            reticleAngle = -UNIT_VECTOR_X.angleTo(direction);
                        }

                        arrow.visible = false;
                    })
                    bReticle2Placed = true;
                    scene.remove(scene.getObjectByName("reticle1"));
                    setTimeout(startGame, 100);
                }
            });

            function startGame() {

                //Create Instance-Handler
                instanceHandler = new InstanceHandler(1, gameLoop);
                instanceHandler.Init();

                //Create an Instance
                game = instanceHandler.GetInstance();

                //Start Instance
                instanceHandler.Start();
            }

            function gameLoop() {

                //Reset arrays
                arrCurrentGameEnemieIDs = [];
                arrObjectsToRemove = [];

                //Game plays automatically
                instanceHandler.Act(Predict(instanceHandler.GetState()));

                game.gameHandler.arrObstacles.forEach(enemieGame => {

                    arrCurrentGameEnemieIDs.push(enemieGame.nObstacleUID);

                    if (!arrCurrentSceneEnemieIDs.includes(enemieGame.nObstacleUID)) {

                        let newEnemieGeometry = new THREE.BoxGeometry(enemieGame.dWidth / scale, enemieGame.dHeight / scale, 25 / scale);
                        let newEnemie = new THREE.Mesh(newEnemieGeometry, ENEMY_MATERIAL);

                        let enemieGamePos = new THREE.Vector3((enemieGame.v2Pos.dX + (enemieGame.dWidth / 2)) / scale, (enemieGame.v2Pos.dY + (enemieGame.dHeight / 2)) / scale, 0);
                        enemieGamePos.applyAxisAngle(UNIT_VECTOR_Y, reticleAngle);
                        newEnemie.rotateOnAxis(UNIT_VECTOR_Y, reticleAngle);

                        newEnemie.position.x = enemieGamePos.x + reticle1.position.x;
                        newEnemie.position.y = enemieGamePos.y + reticle1.position.y;
                        newEnemie.position.z = enemieGamePos.z + reticle1.position.z;

                        newEnemie.name = enemieGame.nObstacleUID.toString();

                        arrCurrentSceneEnemieIDs.push(enemieGame.nObstacleUID);
                        scene.add(newEnemie);
                    }
                });

                //Update the current enemie's positions
                arrCurrentSceneEnemieIDs.forEach(curSceneEnemieID => {
                    let curEnemieObject = scene.getObjectByName(curSceneEnemieID.toString());
                    if (curEnemieObject === null) return;

                    if (!arrCurrentGameEnemieIDs.includes(curSceneEnemieID)) {
                        arrObjectsToRemove.push(curSceneEnemieID);
                        arrCurrentSceneEnemieIDs.shift();
                    } else {
                        game.gameHandler.arrObstacles.forEach(enemieGame => {
                            if (curSceneEnemieID == enemieGame.nObstacleUID) {
                                //Create Vector with current enemie position
                                let enemieGamePos = new THREE.Vector3((enemieGame.v2Pos.dX + (enemieGame.dWidth / 2)) / scale, (enemieGame.v2Pos.dY + (enemieGame.dHeight / 2)) / scale, 0);
                                //Turn enemie around the y-axis 
                                enemieGamePos.applyAxisAngle(UNIT_VECTOR_Y, reticleAngle);
                                //Apply the rotated positions
                                curEnemieObject.position.x = enemieGamePos.x + reticle1.position.x;
                                curEnemieObject.position.z = enemieGamePos.z + reticle1.position.z;
                            }
                        });
                    }
                });

                //Create Player
                if (playerScene === null) {
                    let playerGeometry = new THREE.BoxGeometry(25 / scale, 50 / scale, 25 / scale);
                    playerScene = new THREE.Mesh(playerGeometry, PLAYER_MATERIAL);
                    playerScene.rotateOnAxis(UNIT_VECTOR_Y, reticleAngle);
                    scene.add(playerScene);

                    playerGame = game.gameHandler.player;
                }

                //Update Player
                //Create Vector with current player position
                let playerGamePos = new THREE.Vector3((playerGame.v2Pos.dX + (playerGame.dWidth / 2)) / scale, (playerGame.v2Pos.dY + (playerGame.dHeight / 2)) / scale, 0);
                //Turn player around the y-axis 
                playerGamePos.applyAxisAngle(UNIT_VECTOR_Y, reticleAngle);
                //Apply the rotated positions
                playerScene.position.x = playerGamePos.x + reticle1.position.x;
                playerScene.position.y = playerGamePos.y + reticle1.position.y;
                playerScene.position.z = playerGamePos.z + reticle1.position.z;
                //Update Scale for Ducking/Unducking
                playerScene.scale.y = playerGame.dHeight / 50;


                //Remove all objects
                arrObjectsToRemove.forEach(objectID => {
                    scene.remove(scene.getObjectByName(objectID.toString()));
                });
            }

            // render loop for drawing in AR
            const onXRFrame = (time, frame) => {
                // next draw request
                session.requestAnimationFrame(onXRFrame);

                // bind graphics framebuffer to baseLayer framebuffer
                gl.bindFramebuffer(gl.FRAMEBUFFER, session.renderState.baseLayer.framebuffer);

                // retrieve position of the device WARNING: "XRFrame.getViewerPose" can return null when tracking is tried to be first established
                const pose = frame.getViewerPose(referenceSpace);

                if (pose != null) {
                    const view = pose.views[0];

                    const viewport = session.renderState.baseLayer.getViewport(view);
                    renderer.setSize(viewport.width, viewport.height)

                    // Use the view's transform matrix and projection matrix to configure the THREE.camera
                    camera.matrix.fromArray(view.transform.matrix);
                    camera.projectionMatrix.fromArray(view.projectionMatrix);
                    camera.updateMatrixWorld(true);

                    if (!bReticle2Placed) {
                        const hitTestResults = frame.getHitTestResults(hitTestSource);
                        if (hitTestResults.length > 0 && arrow) {
                            const hitPose = hitTestResults[0].getPose(referenceSpace);
                            arrow.visible = true;
                            arrow.position.set(hitPose.transform.position.x, hitPose.transform.position.y, hitPose.transform.position.z);
                            arrow.updateMatrixWorld(true);
                        }
                    }

                    // render the scene
                    renderer.render(scene, camera);
                }
            }
            session.requestAnimationFrame(onXRFrame);
        }

        //function to Predict
        function Predict(state) {
            if (state.bGame == false || state.arrNObstaclesID[0] == 3) {
                return enumAction.none;
            }

            if (state.arrDDistance[1] + 0.12 * state.nScore - state.arrDDistance[0] + 0.12 * state.nScore < 250 && state.arrDDistance[0] < 120 + 0.12 * state.nScore && (state.arrNObstaclesID[0] == 0 || state.arrNObstaclesID[0] == 1 || state.arrNObstaclesID[0] == 4 || state.arrNObstaclesID[0] == 5)) {
                if (bDuck) {
                    bDuck = false;
                    return enumAction.unduck;
                }
                return enumAction.jump;
            } else if (state.arrDDistance[0] < 120 + 0.12 * state.nScore && state.arrDDistance[0] > 0 + 0.12 * state.nScore && (state.arrNObstaclesID[0] == 0)) {
                if (bDuck) {
                    bDuck = false;
                    return enumAction.unduck;
                }
                return enumAction.jump;
            } else if (state.arrDDistance[0] < 120 + 0.12 * state.nScore && state.arrDDistance[0] > 0 + 0.12 * state.nScore && (state.arrNObstaclesID[0] == 1)) {
                if (bDuck) {
                    bDuck = false;
                    return enumAction.unduck;
                }
                return enumAction.jump;
            } else if (state.arrDDistance[0] < 120 + 0.12 * state.nScore && state.arrDDistance[0] > -25 - 0.12 * state.nScore && (state.arrNObstaclesID[0] == 4)) {
                if (bDuck) {
                    bDuck = false;
                    return enumAction.unduck;
                }
                return enumAction.jump;
            } else if (state.arrDDistance[0] < 120 + 0.12 * state.nScore && state.arrDDistance[0] > -35 - 0.12 * state.nScore && (state.arrNObstaclesID[0] == 5)) {
                if (bDuck) {
                    bDuck = false;
                    return enumAction.unduck;
                }
                return enumAction.jump;
            } else if (state.arrDDistance[0] < 120 + 0.12 * state.nScore && state.arrDDistance[0] > -38 && !(state.arrNObstaclesID[0] == 0 || state.arrNObstaclesID[0] == 1 || state.arrNObstaclesID[0] == 4 || state.arrNObstaclesID[0] == 5)) {
                bDuck = true;
                return enumAction.duck;
            } else {
                if (!state.bGrounded) {
                    bDuck = true;
                    return enumAction.duck;
                }
                bDuck = false;
                return enumAction.unduck;
            }
        }

    </script>
</body>

</html>