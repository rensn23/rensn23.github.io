<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport"
        content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">

        <title>WebXR Demo</title>

        <!-- include three.js -->
        <script src="https://threejs.org/build/three.js"></script>
        <script src="./game.js"></script>
    </head>

    <body>
        <button onclick="activateXR()">Start WebXR</button>

        <script>
            async function activateXR() {
                
                const canvas = document.createElement("canvas");
                document.body.appendChild(canvas);
                const gl = canvas.getContext("webgl", {xrCompatible: true});

                // game-mechanics initialization
                let instanceHandler = new InstanceHandler(1, UpdateView);
                instanceHandler.Init();

                //get an instance and start the game
                let game = instanceHandler.GetInstance();
                instanceHandler.Start();

                // three.js initialization
                const scene = new THREE.Scene();

                const axesHelper = new THREE.AxesHelper(20);
                scene.add(axesHelper);

                // function for updating the objects and the viewer
                function UpdateView() {
                    // update backend
                    instanceHandler.Act(Predict(instanceHandler.GetState()));

                    // if there are obsatcles in the array
                    if (game.gameHandler.arrObstacles.length > 0) {
                        game.gameHandler.arrObstacles.forEach(function(obstacle){
                            
                        });
                    }
                }

                const materials = [
                    new THREE.MeshBasicMaterial({color: 0xff0000}),
                    new THREE.MeshBasicMaterial({color: 0x0000ff}),
                    new THREE.MeshBasicMaterial({color: 0x00ff00}),
                    new THREE.MeshBasicMaterial({color: 0xff00ff}),
                    new THREE.MeshBasicMaterial({color: 0x00ffff}),
                    new THREE.MeshBasicMaterial({color: 0xffff00})
                ];

                // create cube
                const cube = new THREE.Mesh(new THREE.BoxBufferGeometry(0.2, 0.2, 0.2), materials);
                cube.position.set(0, 0, -1);
                scene.add(cube);

                // WebGLRenderer
                const renderer = new THREE.WebGLRenderer({
                    alpha: true,
                    preserveDrawingBuffer: true,
                    canvas: canvas,
                    context: gl
                });
                renderer.autoClear = false;

                // disable matrix auto updates from three.js
                const camera = new THREE.PerspectiveCamera();
                camera.matrixAutoUpdate = false;

                // Initialize WebXR session using "immersive-ar"
                const session = await navigator.xr.requestSession("immersive-ar");
                session.updateRenderState({
                    baseLayer: new XRWebGLLayer(session, gl)
                });
                
                // create a position reference near the user
                const referenceSpace = await session.requestReferenceSpace('local');

                // variables for jumping
                let jump = false;
                let down = false;

                // When user touches the screen
                session.addEventListener("select", (event) => {
                    // When there is not a jump currently happening
                    if (!jump) {
                        jump = true;
                    }
                });

                // render loop for drawing in AR
                const onXRFrame = (time, frame) => {
                    // next draw request
                    session.requestAnimationFrame(onXRFrame);

                    // bind graphics framebuffer to baseLayer framebuffer
                    gl.bindFramebuffer(gl.FRAMEBUFFER, session.renderState.baseLayer.framebuffer);

                    // retrieve position of the device WARNING: "XRFrame.getViewerPose" can return null when tracking is tried to be first established
                    const pose = frame.getViewerPose(referenceSpace);

                    if (pose != null) {
                        const view = pose.views[0];

                        const viewport = session.renderState.baseLayer.getViewport(view);
                        renderer.setSize(viewport.width, viewport.height)

                        // Use the view's transform matrix and projection matrix to configure the THREE.camera
                        camera.matrix.fromArray(view.transform.matrix);
                        camera.projectionMatrix.fromArray(view.projectionMatrix);
                        camera.updateMatrixWorld(true);

                        // render the scene with THREE.WebGLRenderer
                    }

                    // // for jumping
                    // if (jump && cube) {

                    //     // jumps up
                    //     if (cube.position.y <= 0.5 && !down) {
                    //         cube.translateY(0.1);
                    //     }
                    //     else {
                    //         down = true;
                    //     }

                    //     // goes back down
                    //     if (down) {
                    //         if (cube.position.y >= 0.0) {
                    //             cube.translateY(-0.1);
                    //         }
                    //         else {
                    //             down = false;
                    //             jump = false;
                    //         }
                    //     }

                    // }

                    renderer.render(scene, camera);
                }
                session.requestAnimationFrame(onXRFrame);

                bDuck = false;
                //function to Predict
                function Predict(state){
                    if(state.bGame == false ||state.arrNObstaclesID[0] == 3){
                    return enumAction.none;
                    }

                    if(state.arrDDistance[1]+0.12*state.nScore - state.arrDDistance[0]+0.12*state.nScore<250 && state.arrDDistance[0]<120+0.12*state.nScore && (state.arrNObstaclesID[0] == 0||state.arrNObstaclesID[0] == 1||state.arrNObstaclesID[0] == 4||state.arrNObstaclesID[0] == 5)){
                        if(bDuck){
                            bDuck = false;
                            return enumAction.unduck;
                        }
                        return enumAction.jump;
                    }else if(state.arrDDistance[0]<120+0.12*state.nScore && state.arrDDistance[0]>0+0.12*state.nScore &&(state.arrNObstaclesID[0] == 0)){
                        if(bDuck){
                            bDuck = false;
                            return enumAction.unduck;
                        }
                        return enumAction.jump;
                    }else if(state.arrDDistance[0]<120+0.12*state.nScore && state.arrDDistance[0]>0+0.12*state.nScore &&(state.arrNObstaclesID[0] == 1)){
                        if(bDuck){
                            bDuck = false;
                            return enumAction.unduck;
                        }
                        return enumAction.jump;
                    }else if(state.arrDDistance[0]<120+0.12*state.nScore && state.arrDDistance[0]>-25-0.12*state.nScore &&(state.arrNObstaclesID[0] == 4)){
                        if(bDuck){
                            bDuck = false;
                            return enumAction.unduck;
                        }
                        return enumAction.jump;
                    }else if(state.arrDDistance[0]<120+0.12*state.nScore && state.arrDDistance[0]>-35-0.12*state.nScore &&(state.arrNObstaclesID[0] == 5)){
                        if(bDuck){
                            bDuck = false;
                            return enumAction.unduck;
                        }
                        return enumAction.jump;
                    }else if (state.arrDDistance[0]<120+0.12*state.nScore && state.arrDDistance[0]>-38&&!(state.arrNObstaclesID[0] == 0 || state.arrNObstaclesID[0] == 1|| state.arrNObstaclesID[0] == 4|| state.arrNObstaclesID[0] == 5)){
                        bDuck = true;
                        return enumAction.duck;
                    }else{
                        if(!state.bGrounded){
                            bDuck = true;
                            return enumAction.duck;
                        }
                        bDuck = false;
                        return enumAction.unduck;
                    }
                }
            }
        </script>
    </body>
</html>